{"version":3,"file":"docs-script.bundle.js","mappings":"mBAAA,MAAMA,EAAc,IAAIC,IAUxB,SAASC,EAAWC,EAAUC,EAAIC,GAG9B,GAAwB,iBAAbF,EACP,IACIA,EAAWG,SAASC,iBAAiBJ,GAEzC,MAAOK,GAEH,MAAM,IAAIC,aAAa,GADRJ,IAAcK,EAAoB,aAAe,wEAC8BP,MAGlGA,aAAoBQ,YACpBN,EAAUF,EAAUC,GAGpBD,EAASS,SAASC,GAAYR,EAAUQ,EAAST,KAWzD,SAASU,EAAgBD,EAAST,GAC9B,KAAMS,aAAmBF,aACrB,MAAM,IAAII,UAAU,8DAExB,KAAIC,EAAoBH,EAAST,KAKjCS,EAAQI,iBAAiB,QAASb,GAG5BS,aAAmBK,oBAAoB,EACD,IAApCC,EAAuBN,IAIvBA,EAAQI,iBAAiB,UAAWG,GAExC,MAAMC,EA4Jd,SAAyBjB,GACrB,OAAO,SAAUI,GAEb,GADmBc,EAAYd,GAE3B,OAAOJ,EAAGmB,KAAKC,KAAMhB,IAhKNiB,CAAgBrB,GACnCS,EAAQI,iBAAiB,QAASI,GAClC,MAAMK,EAAW,CACbL,WAAAA,GAGJ,KAAMR,aAAmBc,mBAAoB,CAIzC,MAAMC,EA0GlB,SAAsBxB,GAClB,OAAO,SAAUI,GAEb,GAYR,SAAkBA,GAEd,SADmBA,EAAEqB,KAAgC,UAAxBrB,EAAEqB,IAAIC,eAdfC,CAASvB,GAErB,OAAOJ,EAAGmB,KAAKC,KAAMhB,IA9GLwB,CAAa5B,GAC7BS,EAAQI,iBAAiB,UAAWW,GACpCF,EAASE,QAAUA,GAmD/B,SAAkCf,EAAST,EAAIsB,GAC3C,IAAIO,EAAWjC,EAAYkC,IAAIrB,GAC1BoB,IACDA,EAAW,IAAIhC,IAAI,CAAC,CAACG,EAAIsB,KACzB1B,EAAYmC,IAAItB,EAASoB,IAE7B,IAAIG,EAAMH,EAASC,IAAI9B,GACnBgC,EACAC,OAAOC,OAAOF,EAAKV,IAGnBU,EAAMC,OAAOC,OAAO,GAAIZ,GACxBO,EAASE,IAAI/B,EAAIgC,IA7DjBG,CAAyB1B,EAAST,EAAIsB,IAW9C,SAAShB,EAAkBG,EAAST,GAChC,KAAMS,aAAmBF,aACrB,MAAM,IAAII,UAAU,gEAGxBF,EAAQ2B,oBAAoB,QAASpC,GACrC,MAAMsB,EAAWV,EAAoBH,EAAST,GACzCsB,IAMCb,aAAmBK,oBACjBQ,EAASL,YACTR,EAAQ2B,oBAAoB,QAASd,EAASL,YAI5CR,aAAmBc,mBACjBD,EAASE,SACTf,EAAQ2B,oBAAoB,UAAWd,EAASE,SAsChE,SAAgCf,EAAST,GACrC,MAAM6B,EAAWjC,EAAYkC,IAAIrB,GAC5BoB,IAGLA,EAASQ,OAAOrC,GAChBJ,EAAYyC,OAAO5B,IAzCf6B,CAAuB7B,EAAST,IACQ,IAApCe,EAAuBN,IAEvBA,EAAQ2B,oBAAoB,UAAWpB,KA8CnD,SAASJ,EAAoBH,EAAST,GAClC,MAAM6B,EAAWjC,EAAYkC,IAAIrB,GACjC,GAAKoB,EAIL,OADYA,EAASC,IAAI9B,GAU7B,SAASe,EAAuBN,GAC5B,OAAOb,EAAY2C,IAAI9B,GA0B3B,SAASO,EAAuBZ,GAE5B,MAAMK,EAAUW,KAEVoB,EAAW/B,aAAmBK,kBAC9B2B,EAAUhC,aAAmBiC,kBAAoBjC,aAAmBkC,oBACpEC,EAAa1B,EAAYd,GAC1BoC,GAAaC,IAAWG,GACzBxC,EAAEyC,iBAuBV,SAAS3B,EAAYd,GAGjB,SADsBA,EAAEqB,KAAkB,MAAVrB,EAAEqB,KAAuC,aAAxBrB,EAAEqB,IAAIC,eCnO3D,IAAKoB,GAAL,SAAKA,GACJ,kBACA,kBAFD,CAAKA,IAAAA,EAAa,KAKlB,MAAMC,EAAYd,OAAOe,OAAO,CAC/BC,SAAU,eACVC,QAAS,0BAwDV,SAASC,EAAoBC,GAC5B,IAAIC,EAEJ,MAAMC,EAAeF,EAASG,aAAa,iBAU3C,OARID,IACHD,EAAYnD,SAASsD,eAAeF,SAAiBG,GAGjDJ,IACJA,EAAYD,EAASM,QAAqBX,EAAUE,gBAAaQ,GAG3DJ,EAyBR,SAASM,EAAkBN,GAC1B,MAAMO,EAAeP,EAAUE,aAAa,iBAE5C,MAAqB,SAAjBK,EACId,EAAce,OACM,UAAjBD,EACHd,EAAcgB,YADf,EAWR,SAASC,EAAkBV,EAAwBW,GAGlD,GAFqBL,EAAkBN,KAElBW,EACpB,OAGD,MAAMC,EA0DP,SAA8BZ,GAI7B,OAHqBa,MAAMC,KAAKjE,SAASC,iBAA8B4C,EAAUG,UAC1CkB,QAAQhB,GAAaD,EAAoBC,KAAcC,IA5D5EgB,CAAqBhB,GAEvC,OAAQW,GACP,KAAKlB,EAAce,OAClBR,EAAUiB,aAAa,gBAAiB,QACxCL,EAAUzD,SAAS4C,GAAaA,EAASkB,aAAa,gBAAiB,UACvE,MACD,KAAKxB,EAAcgB,OAClBT,EAAUiB,aAAa,gBAAiB,SACxCL,EAAUzD,SAAS4C,GAAaA,EAASkB,aAAa,gBAAiB,YAmB1E,SAASC,IAIR,MAAMC,EAAUtE,SAASuE,cAA2B,WAEpD,GAAID,EAAS,CAEZ,IACC,IAAInB,EAA4CmB,EAAQd,QAAqBX,EAAUE,UACvFI,EACAA,EAAYA,EAAUqB,eAAehB,QAAQX,EAAUE,UAEvDc,EAAkBV,EAAWP,EAAce,QAI5Cc,OAAOC,YAAW,IAAMJ,EAAQK,kBAAkB,IDsEhD/E,EClNMiD,EAAUG,SAWpB,SAAsD9C,GACrD,MAEMgD,EAFUhC,KAESsC,QAAqBX,EAAUG,SACxD,GAAIE,EAAU,CACbhD,EAAEyC,iBAEF,MAAMQ,EAAYF,EAAoBC,GAClCC,GAoCN,SAAyBA,GACVM,EAAkBN,KAElBP,EAAce,OAC3BE,EAAkBV,EAAWP,EAAcgB,QAE3CC,EAAkBV,EAAWP,EAAce,QAzC1CiB,CAAgBzB,MD8LU3C,GChN5BiE,OAAO9D,iBAAiB,aAAc0D,GA+GnBrE,SAASC,iBAA8B4C,EAAUE,UAEzDzC,SAAS6C,GAAcU,EAAkBV,EAAWP,EAAcgB,UA3H7EiB,sBAAsBR,I","sources":["webpack://@cipscis/expander/./node_modules/@cipscis/activate/dist/activate.js","webpack://@cipscis/expander/./src/expander.ts"],"sourcesContent":["const boundEvents = new Map();\r\n/**\r\n * Handles the conversion of the elements parameter so the activator function only ever has to deal with single HTMLElements.\r\n *\r\n * @param {string | HTMLElement | NodeListOf<HTMLElement>} elements - A CSS selector string, HTMLElement, or NodeList of HTMLElements to be converted so the activator function is called once for each resulting HTMLElement.\r\n * @param {ActivateEventListener} fn - The event listener to bind to each HTMLElement.\r\n * @param {(element: HTMLElement, fn: ActivateEventListener) => void} activator - The function to link each HTMLElement to fn.\r\n *\r\n * @throws {DOMException} - If the elements argument is an invalid CSS selector string.\r\n */\r\nfunction _activator(elements, fn, activator) {\r\n    // Share the same initial logic between activate and deactivate,\r\n    // but run a different function over each element\r\n    if (typeof elements === 'string') {\r\n        try {\r\n            elements = document.querySelectorAll(elements);\r\n        }\r\n        catch (e) {\r\n            const method = activator === _deactivateSingle ? 'deactivate' : 'activate';\r\n            throw new DOMException(`${method} failed because it was passed an invalid selector string: '${elements}'`);\r\n        }\r\n    }\r\n    if (elements instanceof HTMLElement) {\r\n        activator(elements, fn);\r\n    }\r\n    else {\r\n        elements.forEach((element) => activator(element, fn));\r\n    }\r\n}\r\n/**\r\n * Binds fn to a single element.\r\n *\r\n * @param {HTMLElement} element\r\n * @param {ActivateEventListener} fn\r\n *\r\n * @throws {TypeError} - element must be an HTMLElement.\r\n */\r\nfunction _activateSingle(element, fn) {\r\n    if (!(element instanceof HTMLElement)) {\r\n        throw new TypeError(`activate failed because a valid HTMLElement was not passed`);\r\n    }\r\n    if (_getElementBindings(element, fn)) {\r\n        // Like addEventListener, don't try to rebind new copies of the same events\r\n        return;\r\n    }\r\n    // All nodes should bind the click event\r\n    element.addEventListener('click', fn);\r\n    // Buttons will already treat keyboard events like clicks,\r\n    // so only bind them to other element types\r\n    if (!(element instanceof HTMLButtonElement)) {\r\n        if (_getElementHasBindings(element) === false) {\r\n            // addEventListener would prevent this event being\r\n            // bound multiple times, but be explicit that it is\r\n            // only bound if the element has no other events bound\r\n            element.addEventListener('keydown', _preventSpacebarScroll);\r\n        }\r\n        const spacebarFn = _makeSpacebarFn(fn);\r\n        element.addEventListener('keyup', spacebarFn);\r\n        const bindings = {\r\n            spacebarFn\r\n        };\r\n        // Links already treat \"enter\" keydown like a click\r\n        if (!(element instanceof HTMLAnchorElement)) {\r\n            // Note that holding down \"enter\" will behave differently\r\n            // for links in that it will only fire once, whereas for\r\n            // non-links, including buttons, it will fire multiple times\r\n            const enterFn = _makeEnterFn(fn);\r\n            element.addEventListener('keydown', enterFn);\r\n            bindings.enterFn = enterFn;\r\n        }\r\n        _rememberElementBindings(element, fn, bindings);\r\n    }\r\n}\r\n/**\r\n * Unbinds fn from a single element.\r\n *\r\n * @param {HTMLElement} element\r\n * @param {ActivateEventListener} fn\r\n *\r\n * @throws {TypeError} - element must be an HTMLElement.\r\n */\r\nfunction _deactivateSingle(element, fn) {\r\n    if (!(element instanceof HTMLElement)) {\r\n        throw new TypeError(`deactivate failed because a valid HTMLElement was not passed`);\r\n    }\r\n    // All elements have had a click event bound\r\n    element.removeEventListener('click', fn);\r\n    const bindings = _getElementBindings(element, fn);\r\n    if (!bindings) {\r\n        // No other events to unbind\r\n        return;\r\n    }\r\n    // Buttons will already treat keyboard events like clicks,\r\n    // so they didn't have keyboard events bound to them\r\n    if (!(element instanceof HTMLButtonElement)) {\r\n        if (bindings.spacebarFn) {\r\n            element.removeEventListener('keyup', bindings.spacebarFn);\r\n        }\r\n        // Links already treat \"enter\" keydown like a click,\r\n        // so that event wasn't bound to them\r\n        if (!(element instanceof HTMLAnchorElement)) {\r\n            if (bindings.enterFn) {\r\n                element.removeEventListener('keydown', bindings.enterFn);\r\n            }\r\n        }\r\n        _forgetElementBindings(element, fn);\r\n        if (_getElementHasBindings(element) === false) {\r\n            // Only unbind this event if the element has no other bindings\r\n            element.removeEventListener('keydown', _preventSpacebarScroll);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Record a new set of bindings for a particular element, associated with a new primary binding.\r\n *\r\n * @param {HTMLElement} element\r\n * @param {ActivateEventListener} fn - The primary binding.\r\n * @param {ActivateBinding} bindings - The secondary bindings.\r\n */\r\nfunction _rememberElementBindings(element, fn, bindings) {\r\n    let elementB = boundEvents.get(element);\r\n    if (!elementB) {\r\n        elementB = new Map([[fn, bindings]]);\r\n        boundEvents.set(element, elementB);\r\n    }\r\n    let fnB = elementB.get(fn);\r\n    if (fnB) {\r\n        Object.assign(fnB, bindings);\r\n    }\r\n    else {\r\n        fnB = Object.assign({}, bindings);\r\n        elementB.set(fn, fnB);\r\n    }\r\n}\r\n/**\r\n * Delete any records of bindings for a particular element and primary binding pair.\r\n *\r\n * @param {HTMLElement} element\r\n * @param {ActivateEventListener} fn\r\n */\r\nfunction _forgetElementBindings(element, fn) {\r\n    const elementB = boundEvents.get(element);\r\n    if (!elementB) {\r\n        return;\r\n    }\r\n    elementB.delete(fn);\r\n    boundEvents.delete(element);\r\n}\r\n/**\r\n * Return the bindings for a particular element and primary binding pair.\r\n *\r\n * @param {HTMLElement} element\r\n * @param {ActivateEventListener} fn\r\n */\r\nfunction _getElementBindings(element, fn) {\r\n    const elementB = boundEvents.get(element);\r\n    if (!elementB) {\r\n        return undefined;\r\n    }\r\n    const fnB = elementB.get(fn);\r\n    return fnB;\r\n}\r\n/**\r\n * Checks whether or not any bindings are recorded for a particular element and primary binding pair.\r\n *\r\n * @param  {HTMLElement} element\r\n *\r\n * @return {boolean}\r\n */\r\nfunction _getElementHasBindings(element) {\r\n    return boundEvents.has(element);\r\n}\r\nfunction _makeEnterFn(fn) {\r\n    return function (e) {\r\n        const isEnter = _isEnter(e);\r\n        if (isEnter) {\r\n            return fn.call(this, e);\r\n        }\r\n    };\r\n}\r\n/**\r\n * For a given KeyboardEvent, checks if it was triggered by the 'enter' key.\r\n *\r\n * @param  {KeyboardEvent} e\r\n *\r\n * @return {boolean}\r\n */\r\nfunction _isEnter(e) {\r\n    const isEnter = !!(e.key && (e.key.toLowerCase() === 'enter'));\r\n    return isEnter;\r\n}\r\n/**\r\n * For a given KeyboardEvent, if it was triggered by the 'spacebar' key, prevent the default action of scrolling the page.\r\n *\r\n * @param {KeyboardEvent} e\r\n */\r\nfunction _preventSpacebarScroll(e) {\r\n    // Prevent spacebar from scrolling the page down on keydown\r\n    const element = this;\r\n    // Buttons and inputs don't have this default action of the 'spacebar' key, so don't prevent it.\r\n    const isButton = element instanceof HTMLButtonElement;\r\n    const isInput = element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement;\r\n    const isSpacebar = _isSpacebar(e);\r\n    if (!isButton && !isInput && isSpacebar) {\r\n        e.preventDefault();\r\n    }\r\n}\r\n/**\r\n * Create a secondary binding that calls fn when triggered via the spacebar.\r\n *\r\n * @param {ActivateEventListener} fn\r\n */\r\nfunction _makeSpacebarFn(fn) {\r\n    return function (e) {\r\n        const isSpacebar = _isSpacebar(e);\r\n        if (isSpacebar) {\r\n            return fn.call(this, e);\r\n        }\r\n    };\r\n}\r\n/**\r\n * Checks if a given KeyboardEvent was triggered by the 'spacebar' key.\r\n *\r\n * @param  {KeyboardEvent} e\r\n *\r\n * @return {boolean}\r\n */\r\nfunction _isSpacebar(e) {\r\n    // IE11 uses 'spacebar' instead of ' '\r\n    const isSpacebar = !!(e.key && (e.key === ' ' || e.key.toLowerCase() === 'spacebar'));\r\n    return isSpacebar;\r\n}\r\n/**\r\n * Bind fn to all specified elements.\r\n *\r\n * @param {string | HTMLElement | NodeListOf<HTMLElement>} elements - The elements to have fn bound to them.\r\n * @param {ActivateEventListener} fn - The event listener to bind.\r\n *\r\n * @throws {DOMException} - If the elements argument is an invalid CSS selector string.\r\n */\r\nfunction activate(elements, fn) {\r\n    _activator(elements, fn, _activateSingle);\r\n}\r\n/**\r\n * Unbind fn from all specified elements.\r\n *\r\n * @param {string | HTMLElement | NodeListOf<HTMLElement>} elements - The elements to have fn unbound from them.\r\n * @param {ActivateEventListener} fn - The event listener to unbind.\r\n *\r\n * @throws {DOMException} - If the elements argument is an invalid CSS selector string.\r\n */\r\nfunction deactivate(elements, fn) {\r\n    _activator(elements, fn, _deactivateSingle);\r\n}\r\nexport { activate, deactivate, };\r\nexport default activate;\r\n//# sourceMappingURL=activate.js.map","import { activate } from '@cipscis/activate';\n\nenum ExpanderState {\n\tOPENED = 'Opened',\n\tCLOSED = 'Closed',\n}\n\nconst selectors = Object.freeze({\n\texpander: '.js-expander',\n\ttrigger: '.js-expander__trigger',\n});\n\n/**\n * Initialise the Expander module.\n */\nfunction init() {\n\t_initEvents();\n\n\t_closeAll();\n\n\t// _openByTarget uses the ':target' CSS pseudo-class, which doesn't\n\t// match anything immediately on page load. Requesting an animation\n\t// frame delays things for long enough for it to work.\n\trequestAnimationFrame(_openByTarget);\n}\n\n/**\n * Initialise events for the Expander module.\n */\nfunction _initEvents() {\n\t// TODO: Use @cipscis/activate\n\tactivate(selectors.trigger, _processTriggerClickEvent);\n\n\twindow.addEventListener('hashchange', _openByTarget);\n}\n\n/**\n * If a trigger element is clicked, determine which expander\n * it controls and toggle its state.\n *\n * @param {MouseEvent} e\n */\nfunction _processTriggerClickEvent(this: HTMLElement, e: MouseEvent | KeyboardEvent): void {\n\tconst $target = this;\n\n\tconst $trigger = $target.closest<HTMLElement>(selectors.trigger);\n\tif ($trigger) {\n\t\te.preventDefault();\n\n\t\tconst $expander = _getTriggerExpander($trigger);\n\t\tif ($expander) {\n\t\t\t_toggleExpander($expander);\n\t\t}\n\t}\n}\n\n/**\n * Determine which expander element is controlled by a given trigger.\n *\n * @param  {HTMLElement} $trigger - The trigger element whose target\n * is being found.\n *\n * @return {HTMLElement} - The expander element controlled\n * by the specified trigger.\n */\nfunction _getTriggerExpander($trigger: HTMLElement): HTMLElement | undefined {\n\tlet $expander: HTMLElement | undefined;\n\n\tconst ariaControls = $trigger.getAttribute('aria-controls');\n\n\tif (ariaControls) {\n\t\t$expander = document.getElementById(ariaControls) || undefined;\n\t}\n\n\tif (!$expander) {\n\t\t$expander = $trigger.closest<HTMLElement>(selectors.expander) || undefined;\n\t}\n\n\treturn $expander;\n}\n\n/**\n * If an expander is open, close it. Otherwise, open it.\n *\n * @param {HTMLElement} $expander - The expander element to toggle.\n */\nfunction _toggleExpander($expander: HTMLElement): void {\n\tconst state = _getExpanderState($expander);\n\n\tif (state === ExpanderState.OPENED) {\n\t\t_setExpanderState($expander, ExpanderState.CLOSED);\n\t} else {\n\t\t_setExpanderState($expander, ExpanderState.OPENED);\n\t}\n}\n\n/**\n * Determine the current state of an expander element.\n *\n * @param  {HTMLElement} $expander - The expander element to check.\n *\n * @return {ExpanderState} - The current state of the expander element.\n */\nfunction _getExpanderState($expander: HTMLElement): ExpanderState | undefined {\n\tconst ariaExpanded = $expander.getAttribute('aria-expanded');\n\n\tif (ariaExpanded === 'true') {\n\t\treturn ExpanderState.OPENED;\n\t} else if (ariaExpanded === 'false') {\n\t\treturn ExpanderState.CLOSED;\n\t}\n}\n\n/**\n * Set the current tate of an expander element.\n *\n * @param {HTMLElement} $expander - The expander element to affect.\n * @param {ExpanderState} state - The desired state of the expander element.\n */\nfunction _setExpanderState($expander: HTMLElement, state: ExpanderState): void {\n\tconst currentState = _getExpanderState($expander);\n\n\tif (currentState === state) {\n\t\treturn;\n\t}\n\n\tconst $triggers = _getExpanderTriggers($expander);\n\n\tswitch (state) {\n\t\tcase ExpanderState.OPENED:\n\t\t\t$expander.setAttribute('aria-expanded', 'true');\n\t\t\t$triggers.forEach(($trigger) => $trigger.setAttribute('aria-expanded', 'true'));\n\t\t\tbreak;\n\t\tcase ExpanderState.CLOSED:\n\t\t\t$expander.setAttribute('aria-expanded', 'false');\n\t\t\t$triggers.forEach(($trigger) => $trigger.setAttribute('aria-expanded', 'false'));\n\t\t\tbreak;\n\t}\n}\n\n/**\n * Close all expanders.\n */\nfunction _closeAll(): void {\n\tconst $expanders = document.querySelectorAll<HTMLElement>(selectors.expander);\n\n\t$expanders.forEach(($expander) => _setExpanderState($expander, ExpanderState.CLOSED));\n}\n\n/**\n * If the :target element is an expander element or a descendent of an\n * expander element, expand all expanders containing it then scroll\n * to that element\n */\nfunction _openByTarget(): void {\n\t// TODO: Allow clicking an anchor link to the current hash to\n\t// force relevant expanders to open again, if they've been closed\n\n\tconst $target = document.querySelector<HTMLElement>(':target');\n\n\tif ($target) {\n\t\t// Loop through all ancestral expanders and open them.\n\t\tfor (\n\t\t\tlet $expander: HTMLElement | null | undefined = $target.closest<HTMLElement>(selectors.expander);\n\t\t\t$expander;\n\t\t\t$expander = $expander.parentElement?.closest(selectors.expander)\n\t\t) {\n\t\t\t_setExpanderState($expander, ExpanderState.OPENED);\n\t\t}\n\n\t\t// Scroll to the target element. Only works if asynchonous\n\t\twindow.setTimeout(() => $target.scrollIntoView(), 0);\n\t}\n}\n\n/**\n * Get all trigger elements that control a given expander element.\n *\n * @param  {HTMLElement} $expander - The expander element whose triggers\n * should be returned.\n *\n * @return {NodeListOf<HTMLElement>} - A list of the triggers controlling\n * the specified expander element.\n */\nfunction _getExpanderTriggers($expander: HTMLElement): HTMLElement[] {\n\tconst $allTriggers = Array.from(document.querySelectorAll<HTMLElement>(selectors.trigger));\n\tconst $matchingTriggers = $allTriggers.filter(($trigger) => _getTriggerExpander($trigger) === $expander);\n\n\treturn $matchingTriggers;\n}\n\nexport {\n\tinit,\n};\n"],"names":["boundEvents","Map","_activator","elements","fn","activator","document","querySelectorAll","e","DOMException","_deactivateSingle","HTMLElement","forEach","element","_activateSingle","TypeError","_getElementBindings","addEventListener","HTMLButtonElement","_getElementHasBindings","_preventSpacebarScroll","spacebarFn","_isSpacebar","call","this","_makeSpacebarFn","bindings","HTMLAnchorElement","enterFn","key","toLowerCase","_isEnter","_makeEnterFn","elementB","get","set","fnB","Object","assign","_rememberElementBindings","removeEventListener","delete","_forgetElementBindings","has","isButton","isInput","HTMLInputElement","HTMLTextAreaElement","isSpacebar","preventDefault","ExpanderState","selectors","freeze","expander","trigger","_getTriggerExpander","$trigger","$expander","ariaControls","getAttribute","getElementById","undefined","closest","_getExpanderState","ariaExpanded","OPENED","CLOSED","_setExpanderState","state","$triggers","Array","from","filter","_getExpanderTriggers","setAttribute","_openByTarget","$target","querySelector","parentElement","window","setTimeout","scrollIntoView","_toggleExpander","requestAnimationFrame"],"sourceRoot":""}